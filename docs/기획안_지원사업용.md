# 빗물받이·침수 위험 관리 플랫폼 — 구현 기획안 (지원사업용)

## 1. 프로젝트 개요

### 1.1 목적
- **빗물받이(배수구) 현황을 한 화면에서 지도·리스트·상세로 통합 관리**하고, **CRI(위험지수) 기반 우선 방문 순서**와 **최적 동선**을 제공합니다.
- **전국 시·도·군·구 단위 필터**와 **선택 구역만의 경계 시각화**로 구역별 집중 모니터링이 가능하도록 했습니다.
- **AI 채팅**으로 사무/현장/데이터 직군별 맞춤 질의응답과, **홍수 예상 히트맵**으로 CRI 50 이상 구역을 직관적으로 파악할 수 있게 했습니다.

### 1.2 대상 사용자
- 지자체·관리자: 빗물받이 현황 대시보드, 시군구 필터, 경계면 확인
- 현장 담당자: 우선 방문 리스트(시→군·구 계층), 최적 동선 분석, 지도 연동
- 사무/데이터 담당자: AI 채팅, 보유자원·작업관리 화면

---

## 2. 시스템 구성 개요

| 구분 | 내용 |
|------|------|
| **프론트엔드** | Next.js(App Router), React, TypeScript, Tailwind CSS |
| **지도** | 네이버 지도 API(NCP), 동선 오버레이·마커·폴리곤 |
| **경계 데이터** | 브이월드 공간정보 API(LT_C_ADSIGG_INFO) — 시군구 경계 WGS84 변환 |
| **AI** | OpenAI 호환 채팅 API(vLLM/Qwen) 연동, 직군별 시스템 프롬프트 |
| **백엔드(선택)** | FastAPI, ML 파이프라인·LLM 오케스트레이터·데이터 수집 API |

---

## 3. 파트별 구현 기획 (어떻게 만들었는가)

### 3.1 빗물받이 현황 대시보드 (Overview)

**목표**  
빗물받이 목록·지도·상세를 한 레이아웃에서 연동하고, 필터·경계·히트맵으로 구역별 위험을 파악할 수 있게 한다.

**구현 방식**
- **레이아웃**: 왼쪽 사이드바(리스트/메뉴) | 중앙 네이버 지도 | 오른쪽 선택 항목 상세 패널. URL(pathname)으로 화면 구분(/, /chat, /resources, /tasks)하여 새로고침 시에도 화면 유지.
- **데이터**: `StormDrainItem` 타입(id, address, lat, lng, status, cri, lastChecked 등)으로 통일. 현재는 목업(`mock-storm-drains`, `mock-drain-detail`) 사용, 추후 REST API로 교체 가능하도록 설계.
- **지도**: Next.js dynamic import로 네이버 지도 클라이언트만 로드. NCP Maps Client ID는 `.env.local`의 `NEXT_PUBLIC_NAVER_MAP_CLIENT_ID`로 주입. 마커 클릭 시 해당 항목 선택·상세 패널 연동, 리스트/검색 클릭 시 `flyTo`로 부드럽게 이동.
- **위험 시각화**: CRI 기준 신호등 방식 — 80 이상 빨강(위험·즉시 청소), 40~80 노랑(주의·관찰), 40 미만 초록(정상). 지도 마커·우선 방문 리스트 카드·범례(MapLegend)에 동일 기준 적용.

---

### 3.2 시·도 / 군·구 2단계 필터 및 선택 구역 경계만 표시

**목표**  
전국 단위로 시·도 → 군·구를 세분화해 필터링하고, 필터 적용 시 **해당 구역의 경계만** 반투명으로 표시하여 다른 지역 경계가 함께 켜지는 문제를 제거한다.

**구현 방식**
- **계층 데이터**: `src/data/sido-sigungu.ts`에 전국 17개 시·도와 각 시·도별 군·구 목록을 행정구역 기준으로 정의(서울 25구, 부산 16구, 경기 31개 시군 등). `getSigunguBySido(sidoName)`으로 군·구 옵션 제공.
- **필터 UI**: `DashboardMapFilters`에서 **시·도** 셀렉트(전체, 서울특별시, 부산광역시, …)와 **군·구** 셀렉트(선택한 시·도의 군·구 + 전체) 2단계로 구성. `MapFilterValues`는 `sido`, `gunGu`, date, severity50Only 로 관리.
- **필터 로직**: 군·구를 선택하면 주소에 해당 군·구명 포함 여부로 필터; 시·도만 선택(군·구 전체)이면 시·도명에서 “특별시·광역시·도” 등을 제거한 키워드(예: 서울, 부산, 경기)로 주소 매칭.
- **경계 표시**: 브이월드 API로 로드한 시군구 경계(`DistrictPolygon[]`)는 현재 서울 시군구만 사용. **선택 구역만 표시**하도록 `districtBoundariesToShow`를 다음처럼 계산한다.  
  - `effectiveDistrict === "전체"`: “시군구 구역 표시” 버튼 on 시에만 전체 경계 표시.  
  - `effectiveDistrict`가 특정 군·구명(예: 강남구): 해당 이름과 일치하는 폴리곤만 전달.  
  - `effectiveDistrict`가 시·도명(예: 서울특별시): 해당 시·도에 속한 경계만 표시(현재 데이터는 서울만 있으므로 서울 선택 시 전체 구 경계).  
  따라서 필터를 켜면 **해당 구역의 경계면만** 반투명 폴리곤으로 표시되고, 다른 지역 경계는 그리지 않는다.

---

### 3.3 시군구 경계 데이터 연동 (브이월드)

**목표**  
공공 공간정보로 시군구 경계를 가져와 네이버 지도 위에 반투명 폴리곤으로 겹쳐 보여 준다.

**구현 방식**
- **API**: 브이월드 데이터 API `LT_C_ADSIGG_INFO`, `sig_cd` 조건으로 시도별 시군구 조회. 현재는 서울(sig_cd 11)만 조회하는 `fetchSeoulDistrictBoundaries` 사용. 좌표는 EPSG:4326 요청 후 실패 시 EPSG:3857 수신·WGS84 변환(`vworld-coord`, 링 단순화 적용).
- **Next.js API 라우트**: `GET /api/vworld-boundaries`에서 호스트/프로토콜로 도메인 구성 후 브이월드 호출, 클라이언트에는 GeoJSON 형태의 `DistrictPolygon[]`(id, name, positions: [lat,lng][][]) 반환.
- **지도 연동**: `NaverMap`에 `districtBoundaries` prop으로 전달. 각 구역별 폴리곤·폴리라인 및 구역명 라벨 마커를 그리며, 클릭 시 `onDistrictClick`으로 구역 선택(예: CRI 필터용) 연동. **히트맵 토글 등 오버레이 갱신 시** 현재 지도 중심·줌을 저장했다가 갱신 후 복원하여, 사용자가 보던 위치가 바뀌지 않도록 처리.

---

### 3.4 우선 방문 리스트 (시 → 군·구 계층) 및 최적 동선

**목표**  
CRI가 높은 순으로 방문할 지점을 **시를 최상위, 그 아래 군·구**로 계층화해 보여 주고, “최적 동선 분석”으로 고위험 우선·거리 최소화 경로를 제시한다.

**구현 방식**
- **계층 구조**: 주소에서 `getCityFromAddress`(예: 서울시→서울특별시), `getDistrictFromAddress`(군·구 추출)로 시·군·구를 파싱. `groupedByCityThenDistrict`는 시 이름 → (군·구 이름 → 항목 배열) 2단계 Map으로 그룹핑 후, 시·군·구·항목 각각 정렬(시·군·구 가나다, 항목은 CRI 내림차순).
- **토글**: 시 단위는 `collapsedCities`, 군·구 단위는 `collapsedDistricts`(키는 `"시이름|군구이름"`으로 구분). 시 행 클릭 시 해당 시만 펼치/접기, 군·구 행 클릭 시 해당 군·구만 펼치/접기.
- **UI**: 1단계 — 시 이름 + ▼/▶ + 개수; 2단계 — 시 펼침 시 군·구 행(이름 + 개수); 3단계 — 군·구 펼침 시 기존 빗물받이 카드 리스트(CRI, 주소, 관리번호 등). 리스트 항목 클릭 시 지도 `flyTo`로 이동.
- **최적 동선**: `lib/optimal-route.ts`의 `computeOptimalRoute`. CRI 내림차순으로 고위험 우선 정렬한 뒤, 현재 지점에서 Haversine 거리가 가장 가까운 다음 지점을 반복 선택해 경로 구성. 생성된 경로는 지도에 `RouteOverlay`로 표시하고, “최적 동선 분석” 실행 시 첫 지점으로 이동 후 순차적으로 포인트 이동(타이머).

---

### 3.5 홍수 예상 히트맵

**목표**  
CRI 50 이상 지점을 지도 위에서 한눈에 보이도록 하고, 토글 시 **지도 위치는 유지**한다.

**구현 방식**
- **표시**: CRI≥50인 항목에 대해 반투명 적색 원형 마커(div)를 네이버 지도 마커로 추가. `showHeatmap` prop으로 on/off.
- **위치 유지**: 히트맵·마커·폴리곤 갱신 시 실행되는 effect에서, 갱신 전에 `getCenter()`·`getZoom()`으로 현재 뷰를 저장하고, 오버레이 갱신 후 `setCenter`·`setZoom`으로 복원하여 보고 있던 위치가 바뀌지 않도록 처리.

---

### 3.6 AI 채팅 (LLM 연동)

**목표**  
사용자 질문에 대해 직군(사무/현장/데이터)별로 다른 톤의 답변을 제공하고, 수치·데이터는 마크다운 테이블로 정리한다.

**구현 방식**
- **클라이언트**: `src/lib/llm-api.ts`에서 OpenAI 호환 `POST /v1/chat/completions` 호출. `NEXT_PUBLIC_LLM_API_URL` 또는 기본 노바로보틱스 vLLM 서버 URL 사용. 직군별 `getSystemPrompt(role)`로 시스템 프롬프트 첫 줄 주입(사무: 전략·비용·기획, 현장: 안전·작업 효율, 데이터: 수치·통계).
- **옵션**: temperature, top_p, max_tokens, stop 시퀀스(qwen), timeout 설정. 실패 시 `SERVER_ERROR_MESSAGE`로 안내.
- **채팅 UI**: `ChatView`에서 채팅 목록·선택·메시지 목록 관리. 로컬 스토리지에 채팅 목록·선택 ID 저장/복원하여 탭 전환·새로고침 후에도 유지.

---

### 3.7 보유자원·작업관리 화면

**목표**  
리소스 현황과 작업 할당·관제·검수 정보를 메뉴에서 선택해 볼 수 있게 한다.

**구현 방식**
- **라우팅**: `/resources` → ResourcesView, `/tasks` → TaskManagementView. 사이드바에서 해당 메뉴 클릭 시 pathname 변경으로 전환.
- **데이터**: 각각 목업 데이터(`mock-resources`, `mock-task-management` 등)를 사용하며, 추후 백엔드 API로 교체 가능한 구조로 두었다.

---

### 3.8 백엔드(선택) — 데이터 수집·ML·LLM 오케스트레이션

**목표**  
모바일 앱 등에서 수집한 빗물받이 데이터를 저장하고, ML로 위험 지표(priority_score, flood_probability, cri 등)를 산출한 뒤, 채팅 질의 시 LLM이 해당 수치를 해석해 실행 가능한 권고를 제공한다.

**구현 방식**
- **아키텍처**: FastAPI 앱, Data Ingestion API → DB, ML Pipeline이 DB에 지표 저장, Chat API → LLM Orchestrator → vLLM(Tailscale). Intent 라우팅·Context 조회·Prompt 합성·Tool Calling(get_drainage_data, generate_risk_chart, send_admin_alert).
- **API**: `POST /ingestion/drainage`, `POST /chat/query`, `GET /health`. DB 스키마는 location_id, volume_L, max_height_mm, priority_score, risk_reason, flood_probability, cri 등으로 ML 팀과 협의된 형태.
- **내결함성**: LLM 타임아웃/오류 시 fallback 메시지, ML 데이터 미준비 시 기본값·fallback 응답.

---

## 4. 기술 스택 요약

| 영역 | 기술 |
|------|------|
| 프론트 | Next.js 14+(App Router), React 18, TypeScript, Tailwind CSS |
| 지도 | Naver Maps API (NCP), 동선·마커·폴리곤 |
| 공간정보 | 브이월드 API (LT_C_ADSIGG_INFO), WGS84 변환·링 단순화 |
| AI | OpenAI 호환 Chat Completions (vLLM/Qwen), 직군별 시스템 프롬프트 |
| 백엔드 | FastAPI, 비동기 DB, ML 파이프라인, LLM 오케스트레이터 |

---

## 5. 문서·버전

- 본 기획안은 실제 구현(코드베이스)을 기준으로 “어떻게 만들었는가”를 정리한 문서이며, 지원사업 신청서의 **구현 기획·기술 설명** 파트에 활용할 수 있습니다.
- 필요 시 “예상 효과”, “추가 확장(전국 시도별 경계 로드 등)” 섹션을 지원사업 양식에 맞춰 추가하면 됩니다.
